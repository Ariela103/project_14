#include "data.h"
void resetMemoryCounters();
void initTables();
void exportFiles();
void closeOpenLogFiles();
void allocMemoryImg();
void calcFinalAddrsCountersValues();
void freeHashTable(ItemType type);

int main(int argc, char *argv[])
{
    /*
     * The main function initializes the assembler by passing the command-line arguments (the source file names)
     * to the `handleSourceFiles` function. The assembler processes each file provided via command-line arguments.
     */
    handleSourceFiles(argc, argv);
    return 0;
}

int handleSourceFiles(int argc, char *argv[])
{
    /*
     * `handleSourceFiles` processes all the files passed to the assembler via the command line.
     * The function checks if any files are provided; if not, it exits with an error message.
     * It then iterates through each file and passes them to `handleSingleFile` for individual file processing.
     */
    int filesCount = argc - 1; /* The number of source files passed (excluding the program name) */
    int i = 1;                 /* Index to iterate through the files */

    if (filesCount < 1)
    {
        /* If no files are provided, display an error and exit the program */
        fprintf(stderr, "\n\nNo source files were provided for the assembler!\n\n");
        exit(1);
    }

    /* Loop through all the files passed via command-line arguments */
    while (--argc)
    {
        handleSingleFile(argv[i]);
        i++;
    }

    return 0;
}

void handleSingleFile(char *arg)
{
    FILE *src = NULL, *target = NULL;
    void (*setPath)(char *) = &setFileNamePath;
    State (*globalState)() = &getGlobalState;
    void (*setState)(State) = &setGlobalState;
    char *fileName = (char *)calloc(strlen(arg) + 4, sizeof(char *)); /* Allocating memory for the file name with extension */

    /*
     * The base file name is set by copying the original file name (arg) and appending ".as"
     * to mark it as an assembly source file.
     */
    strncpy(fileName, arg, strlen(arg)); /* Copy the base name of the file */
    strcat(fileName, ".as");             /* Append ".as" to make it an assembly source file */
    (*setPath)(fileName);                /* Set the file path using the base file name */

    /*
     * Open the source file for reading. If the file cannot be opened (e.g., it doesn't exist),
     * an error message is printed to the user, and the function exits, releasing any allocated memory.
     */
    if ((src = fopen(fileName, "r")) == NULL)
    {
        fprintf(stderr, "\n######################################################################\n");
        fprintf(stderr, " ERROR: Could not open source file %s\n", fileName);
        fprintf(stderr, "######################################################################\n\n");
        free(fileName); /* Free the allocated memory for fileName */
        return;         /* Exit the function as the file couldn't be opened */
    }

    /*
     * Change the file extension from ".as" to ".am" to represent the expanded source file.
     * This file will be generated by expanding macros in the source code.
     */
    fileName[strlen(fileName) - 1] = 'm'; /* Replace the 's' in ".as" with 'm' to make it ".am" */
    (*setPath)(fileName);                 /* Update the path to point to the ".am" file */

    /*
     * Open the target file for writing the expanded source code (macro-expanded).
     * If the file cannot be created, an error message is displayed, and the original source file is closed.
     */
    if ((target = fopen(fileName, "w+")) == NULL)
    {
        fprintf(stderr, "\n######################################################################\n");
        fprintf(stderr, " ERROR: Failed to create expanded source file %s\n", fileName);
        fprintf(stderr, "######################################################################\n\n");
        fclose(src);    /* Close the source file */
        free(fileName); /* Free the memory allocated for the file name */
        return;
    }

    /*
     * The file has been successfully opened, so we proceed to initialize various tables and
     * prepare for the macro expansion and parsing phase.
     */
    else
    {
        initTables(); /* Initialize tables used for storing macros, symbols, etc. */

        /*
         * Start by parsing and expanding macros in the source code.
         * The `resetMemoryCounters` function resets memory address counters, and
         * `parseSourceFile` expands macros and writes the result to the target file.
         */
        (*setState)(parsingMacros); /* Set the state to "parsing macros" */
        resetMemoryCounters();
        parseSourceFile(src, target); /* Parse the source file to handle macros */
        printMacroTable();            /* Print the macro table after parsing */
        freeHashTable(Macro);         /* Free the memory used by the macro hash table */

        /*
         * The first run starts after macro parsing. This phase checks for syntax errors,
         * calculates memory addresses, and begins parsing the assembly code.
         */
        if ((*globalState)() == firstRun)
        {
            rewind(target);            /* Reset the file pointer to the start of the target file */
            parseAssemblyCode(target); /* Perform the first pass of assembly parsing */

            /*
             * If the first run completes without errors, the second run begins. In this run,
             * final memory addresses are calculated, the memory image is constructed, and the
             * symbol table is finalized.
             */
            if ((*globalState)() == secondRun)
            {
                calcFinalAddrsCountersValues(); /* Calculate final memory addresses */
                updateFinalSymbolTableValues(); /* Update the symbol table with final values */
                allocMemoryImg();               /* Allocate memory for the memory image */
                printSymbolTable();             /* Print the symbol table */
                rewind(target);                 /* Rewind the target file for another pass */
                parseAssemblyCode(target);      /* Perform the second pass of assembly parsing */

                /*
                 * If no errors are encountered during the second run, we proceed to export the output files:
                 * the object file (.ob), the entries file (.ent), and the externals file (.ext).
                 */
                if ((*globalState)() == createOutputFiles)
                {
                    fileName[strlen(fileName) - 3] = '\0'; /* Remove the ".am" extension */
                    (*setPath)(fileName);                  /* Set the path to the base file name */
                    exportFiles();                         /* Export the files (.ob, .ent, .ext) */
                }
                else
                    printf("\nErrors encountered in second run, output files will not be created.\n");
            }
            else
                printf("\nErrors encountered in first run, second run and file export will be skipped.\n");

            freeHashTable(Symbol); /* Free the symbol table after processing */
        }
        else
            printf("\nMacro expansion for %s failed due to errors.\nMoving on to the next file.\n\n", fileName);

        /*
         * Finally, free any allocated memory and close the files that were opened.
         * The log files created during the process are also closed.
         */
        free(fileName);      /* Free the memory allocated for the file name */
        fclose(src);         /* Close the source file */
        fclose(target);      /* Close the target file */
        closeOpenLogFiles(); /* Close any open log files */
    }
}
